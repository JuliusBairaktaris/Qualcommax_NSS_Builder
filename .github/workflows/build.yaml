name: OpenWrt Build

on:
  workflow_dispatch:
  push:
    branches: [main]
  schedule:
    - cron: "0 */2 * * *"

concurrency:
  group: openwrt-${{ github.workflow }}-${{ github.ref_type }}-${{ github.ref_name || github.run_id }}
  cancel-in-progress: false

permissions:
  contents: read

defaults:
  run:
    shell: bash

env:
  # === Repository Config ===
  REMOTE_REPOSITORY: qosmio/openwrt-ipq
  REMOTE_BRANCH: main-nss
  NSS_PACKAGES_REPOSITORY: qosmio/nss-packages
  NSS_PACKAGES_REPOSITORY_BRANCH: NSS-12.5-K6.x

  # === Build Config ===
  CONFIG_FILE: ax3600.config
  CUSTOM_FILES_PATH: files
  USE_CCACHE: 1

  # === Release Config ===
  RELEASE_PREFIX: main-nss
  ARTIFACT_RETENTION_DAYS: 7
  RELEASES_TO_KEEP: 2

jobs:
  detect-updates:
    name: Detect upstream changes
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    permissions:
      contents: read
    env:
      GH_TOKEN: ${{ github.token }}
    outputs:
      build_required: ${{ steps.diff.outputs.build_required }}
      main_sha: ${{ steps.diff.outputs.main_sha }}
      nss_sha: ${{ steps.diff.outputs.nss_sha }}
    steps:
      - name: Check for updates
        id: diff
        run: |
          set -euo pipefail

          # Fetch upstream SHAs
          main_sha=$(gh api "repos/${REMOTE_REPOSITORY}/commits/${REMOTE_BRANCH}" --jq .sha)
          nss_sha=$(gh api "repos/${NSS_PACKAGES_REPOSITORY}/commits/${NSS_PACKAGES_REPOSITORY_BRANCH}" --jq .sha)
          latest_release_body=$(gh release view --repo "${GITHUB_REPOSITORY}" --json body --jq .body 2>/dev/null || echo "")

          # Determine if build is required
          build_required=true
          if [[ "${GITHUB_EVENT_NAME}" != "workflow_dispatch" ]] && \
             [[ "$latest_release_body" == *"$main_sha"* ]] && \
             [[ "$latest_release_body" == *"$nss_sha"* ]]; then
            build_required=false
          fi

          # Output results
          cat >> "$GITHUB_OUTPUT" <<EOF
          build_required=$build_required
          main_sha=$main_sha
          nss_sha=$nss_sha
          EOF

  build:
    name: Build image
    needs: detect-updates
    if: needs.detect-updates.outputs.build_required == 'true' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-24.04
    timeout-minutes: 360
    permissions:
      contents: read
      actions: read
    env:
      MAIN_SHA: ${{ needs.detect-updates.outputs.main_sha }}
      NSS_SHA: ${{ needs.detect-updates.outputs.nss_sha }}
    steps:
      # === SETUP ===
      - name: Install dependencies
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential ccache clang flex bison g++ gawk gcc-multilib g++-multilib gettext git \
            libncurses5-dev libssl-dev python3-setuptools rsync swig unzip zlib1g-dev file wget

      - name: Checkout sources
        uses: actions/checkout@v5
        with:
          repository: ${{ env.REMOTE_REPOSITORY }}
          ref: ${{ env.MAIN_SHA }}
          fetch-depth: 0
          persist-credentials: false

      - name: Checkout builder assets
        uses: actions/checkout@v5
        with:
          path: builder_repo
          fetch-depth: 0
          persist-credentials: false

      # === CACHE CONFIGURATION ===
      - name: Generate cache keys
        id: cache-keys
        run: |
          set -euo pipefail

          # Calculate hashes
          config_hash=$(sha256sum "builder_repo/${CONFIG_FILE}" | cut -d' ' -f1)
          
          patch_hash="none"
          if compgen -G 'builder_repo/patches/*.patch' >/dev/null; then
            patch_hash=$(find builder_repo/patches -maxdepth 1 -type f -name '*.patch' -print0 | \
              sort -z | xargs -0 sha256sum | sha256sum | cut -d' ' -f1)
          fi

          custom_hash="none"
          if [ -d "builder_repo/${CUSTOM_FILES_PATH}" ] && \
             [ -n "$(find "builder_repo/${CUSTOM_FILES_PATH}" -type f -printf '.' -quit)" ]; then
            custom_hash=$(find "builder_repo/${CUSTOM_FILES_PATH}" -type f -print0 | \
              sort -z | xargs -0 sha256sum | sha256sum | cut -d' ' -f1)
          fi

          # Export keys
          cat >> "$GITHUB_OUTPUT" <<EOF
          config=$config_hash
          patches=$patch_hash
          custom=$custom_hash
          base=${{ runner.os }}-${config_hash}-${patch_hash}-${custom_hash}
          EOF

      - name: Restore downloads cache
        uses: actions/cache@v4
        with:
          path: dl
          key: downloads-${{ steps.cache-keys.outputs.base }}
          restore-keys: |
            downloads-${{ steps.cache-keys.outputs.base }}-
            downloads-${{ runner.os }}-

      - name: Restore toolchain cache
        uses: actions/cache@v4
        with:
          path: staging_dir
          key: toolchain-${{ runner.os }}-${{ steps.cache-keys.outputs.config }}-${{ env.MAIN_SHA }}
          restore-keys: |
            toolchain-${{ runner.os }}-${{ steps.cache-keys.outputs.config }}-
            toolchain-${{ runner.os }}-

      - name: Restore build objects cache
        uses: actions/cache@v4
        with:
          path: build_dir
          key: build-${{ steps.cache-keys.outputs.base }}-${{ env.MAIN_SHA }}-${{ env.NSS_SHA }}

      - name: Restore ccache
        uses: actions/cache@v4
        with:
          path: .ccache
          key: ccache-${{ steps.cache-keys.outputs.base }}
          restore-keys: |
            ccache-${{ steps.cache-keys.outputs.base }}-
            ccache-${{ runner.os }}-

      # === BUILD ===
      - name: Configure build
        run: |
          set -euo pipefail

          # Ccache setup
          mkdir -p .ccache
          cat >> "$GITHUB_ENV" <<EOF
          CCACHE_DIR=${GITHUB_WORKSPACE}/.ccache
          CCACHE_MAXSIZE=8G
          CCACHE_COMPRESS=1
          CCACHE_BASEDIR=${GITHUB_WORKSPACE}
          CCACHE_NOHASHDIR=1
          CCACHE_COMPILERCHECK=content
          CCACHE_SLOPPINESS=time_macros,include_file_mtime
          EOF

          # Reproducible build setup
          main_epoch=$(git show -s --format=%ct "${MAIN_SHA:-HEAD}")
          cat >> "$GITHUB_ENV" <<EOF
          SOURCE_DATE_EPOCH=$main_epoch
          TZ=UTC
          LC_ALL=C
          KBUILD_BUILD_USER=builder
          KBUILD_BUILD_HOST=github
          EOF

      - name: Apply patches and feeds
        run: |
          set -euo pipefail

          # Apply patches
          if compgen -G 'builder_repo/patches/*.patch' >/dev/null; then
            while IFS= read -r patch; do
              git apply --verbose "$patch"
            done < <(find builder_repo/patches -maxdepth 1 -type f -name '*.patch' | sort)
          fi

          # Install feeds
          ./scripts/feeds update -a
          ./scripts/feeds install -a

      - name: Prepare configuration
        run: |
          set -euo pipefail

          cp "builder_repo/${CONFIG_FILE}" .config
          make defconfig

          if [ -d "builder_repo/${CUSTOM_FILES_PATH}" ]; then
            mkdir -p "${CUSTOM_FILES_PATH}"
            rsync -a "builder_repo/${CUSTOM_FILES_PATH}/" "${CUSTOM_FILES_PATH}/"
          fi

      - name: Build firmware
        run: |
          set -euo pipefail

          # Setup ccache logging
          log_dir=$(mktemp -d)
          export CCACHE_LOGFILE="${log_dir}/ccache.log"
          echo "CCACHE_LOGFILE=${CCACHE_LOGFILE}" >> "$GITHUB_ENV"
          ccache -s || true

          # Build
          make download -j"$(nproc)" V=s
          if ! make -j"$(nproc)"; then
            make -j1 V=s
          fi

          # Stats
          ccache -s

      - name: Upload ccache log
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: ccache-log-${{ github.run_id }}-${{ github.run_attempt }}
          path: ${{ env.CCACHE_LOGFILE != '' && env.CCACHE_LOGFILE || '/tmp/ccache.log' }}
          if-no-files-found: ignore

      - name: Upload images
        uses: actions/upload-artifact@v5
        with:
          name: ipq807x-images
          path: bin/targets/qualcommax/ipq807x
          if-no-files-found: error
          retention-days: ${{ env.ARTIFACT_RETENTION_DAYS }}

  release:
    name: Publish release
    needs: [detect-updates, build]
    if: needs.build.result == 'success'
    runs-on: ubuntu-24.04
    timeout-minutes: 20
    permissions:
      contents: write
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v6
        with:
          name: ipq807x-images
          path: firmware

      - name: Create release
        run: |
          set -euo pipefail

          date=$(date -u +%F)
          timestamp=$(date -u +%Y%m%dT%H%M%SZ)
          tag_name="${RELEASE_PREFIX}-${timestamp}-${GITHUB_RUN_ID}"

          gh release create "$tag_name" \
            --title "OpenWrt Build $date" \
            --notes "## OpenWrt Automated Build
            - Main commit: \`${{ needs.detect-updates.outputs.main_sha }}\`
            - NSS packages commit: \`${{ needs.detect-updates.outputs.nss_sha }}\`
            - Trigger: \`${{ github.event_name }}\`" \
            firmware/*

  prune-releases:
    name: Prune old releases
    needs: release
    if: always()
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    permissions:
      contents: write
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Prune releases
        run: |
          set -euo pipefail

          keep="${RELEASES_TO_KEEP:-2}"
          
          # Fetch and filter releases
          gh api "repos/${GITHUB_REPOSITORY}/releases?per_page=100" | \
          jq -r --argjson keep "$keep" '
            map(select(.draft | not)) | sort_by(.created_at) | reverse | .[$keep:] | .[] | "\(.id) \(.tag_name)"
          ' | while read -r release_id tag_name; do
            echo "Deleting release $release_id (tag: $tag_name)"
            gh api -X DELETE "repos/${GITHUB_REPOSITORY}/releases/${release_id}"
            gh api -X DELETE "repos/${GITHUB_REPOSITORY}/git/refs/tags/${tag_name}" || true
          done
